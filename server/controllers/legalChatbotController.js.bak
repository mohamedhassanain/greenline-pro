import { GoogleGenerativeAI } from '@google/generative-ai';
import { supabase, checkSupabaseConnection } from '../config/supabase.js';

// V√©rifier la connexion √† Supabase au d√©marrage
checkSupabaseConnection().catch(console.error);

// V√©rification de la cl√© API
if (!process.env.GEMINI_API_KEY) {
  console.error('ERREUR: La cl√© API Gemini n\'est pas configur√©e');
  process.exit(1);
}

// Initialisation du client Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Fonction pour v√©rifier si un utilisateur est administrateur
async function isUserAdmin(userId) {
  console.log(`V√©rification du r√¥le admin pour l'utilisateur ${userId}...`);
  try {
    const { data, error } = await supabase
      .from('users')
      .select('role')
      .eq('id', userId)
      .single();
      
    if (error) throw error;
    
    const isAdmin = data?.role === 'admin';
    console.log(`R√¥le de l'utilisateur ${userId}: ${data?.role || 'non trouv√©'}, Admin: ${isAdmin}`);
    return isAdmin;
  } catch (error) {
    console.error('Erreur lors de la v√©rification du r√¥le admin:', {
      userId,
      error: error.message,
      stack: error.stack
    });
    return false;
  }
}

// Fonction pour construire le prompt syst√®me en fonction du r√¥le
function buildSystemPrompt(isAdmin) {
  const currentDate = new Date().toLocaleDateString('fr-FR', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });

  const basePrompt = `Vous √™tes un assistant juridique professionnel. 
    R√©pondez de mani√®re claire, pr√©cise et professionnelle aux questions juridiques.
    Date actuelle: ${currentDate}.
    `;

  if (isAdmin) {
    return basePrompt + `
    [MODE ADMIN ACTIV√â]
    - Vous avez acc√®s √† des fonctionnalit√©s avanc√©es
    - Vous pouvez g√©rer les utilisateurs et les param√®tres du syst√®me
    - Vous pouvez acc√©der √† des informations sensibles
    - Soyez particuli√®rement attentif aux demandes administratives
    - V√©rifiez toujours les permissions avant d'effectuer des actions sensibles
    - Signalez clairement quand vous utilisez des privil√®ges d'administrateur
    `;
  }

  return basePrompt + `
    [MODE UTILISATEUR]
    - Vous r√©pondez aux questions juridiques g√©n√©rales
    - Pour les questions sp√©cifiques √† un cas, pr√©cisez que vous fournissez des informations g√©n√©rales
    - En cas de doute, recommandez de consulter un avocat
    - Ne donnez pas de conseils juridiques engageants
    `;
}

// Fonction pour r√©cup√©rer l'historique d'une conversation
async function getConversationHistory(conversationId) {
  try {
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });
      
    if (error) throw error;
    return data || [];
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration de l\'historique:', error);
    throw error;
  }
}

// Fonction pour cr√©er ou r√©cup√©rer une conversation
async function getOrCreateConversation(userId) {
  console.log(`D√©but de getOrCreateConversation pour l'utilisateur ${userId}`);
  try {
    console.log('Recherche d\'une conversation active r√©cente...');
    // V√©rifier s'il existe une conversation active r√©cente (moins de 30 minutes)
    const { data, error } = await supabase
      .from('conversations')
      .select('id')
      .eq('user_id', userId)
      .eq('is_active', true)
      .gt('created_at', new Date().toISOString() - 30 * 60 * 1000)
      .order('created_at', { ascending: false })
      .limit(1);

    if (error) throw error;

    if (data.length > 0) {
      console.log(`Conversation existante trouv√©e: ${data[0].id}`);
      return data[0];
    }

    console.log('Aucune conversation r√©cente trouv√©e, cr√©ation d\'une nouvelle conversation...');
    // Cr√©er une nouvelle conversation
    const { data: newConversation, error: insertError } = await supabase
      .from('conversations')
      .insert([
        {
          user_id: userId,
          title: 'Nouvelle conversation',
          created_at: new Date().toISOString()
        }
      ])
      .select();

    if (insertError) throw insertError;

    console.log(`Nouvelle conversation cr√©√©e: ${newConversation[0].id}`);
    return newConversation[0];
  } catch (error) {
    console.error('Erreur lors de la cr√©ation/r√©cup√©ration de la conversation:', {
      userId,
      error: error.message,
      stack: error.stack
    });
    throw error;
  }
}

// Fonction pour enregistrer un message
async function saveMessage(conversationId, role, content, userId) {
  try {
    // V√©rifier si la conversation appartient √† l'utilisateur
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId)
      .single();

    if (convError || !conversation) {
      throw new Error('Conversation non trouv√©e ou acc√®s non autoris√©');
    }

    // Enregistrer le message
    const { data: message, error: insertError } = await supabase
      .from('messages')
      .insert([
        {
          conversation_id: conversationId,
          role,
          content,
          user_id: userId,
          created_at: new Date().toISOString()
        }
      ])
      .select();

    if (insertError) throw insertError;

    // Mettre √† jour la date de mise √† jour de la conversation
    await supabase
      .from('conversations')
      .update({ updated_at: new Date().toISOString() })
      .eq('id', conversationId);

    return message[0];
  } catch (error) {
    console.error('Erreur lors de l\'enregistrement du message:', error);
    throw error;
  }
}

// Fonction principale du chatbot

// Configuration des r√¥les disponibles
const ROLE_CONFIG = {
  assistant: {
    name: 'Assistant',
    description: 'R√©ponses g√©n√©rales et aide basique',
    color: 'bg-blue-500',
    systemPrompt: `Tu es un assistant juridique professionnel. 
      - Fournis des r√©ponses claires et concises
      - Reste sur des informations g√©n√©rales
      - Pour des conseils sp√©cifiques, recommande de consulter un expert`,
    allowedRoles: ['*']
  },
  expert: {
    name: 'Expert',
    description: 'Analyse technique et conseils avanc√©s',
    color: 'bg-purple-500',
    systemPrompt: `Tu es un expert juridique avec des connaissances approfondies.
      - Fournis des analyses techniques d√©taill√©es
      - Donne des conseils pr√©cis avec r√©f√©rences l√©gales
      - Sois exhaustif dans tes explications`,
    allowedRoles: ['admin', 'expert']
  },
  support: {
    name: 'Support',
    description: 'Aide et assistance client',
    color: 'bg-green-500',
    systemPrompt: `Tu es un agent de support client.
      - Sois empathique et √† l'√©coute
      - Aide √† r√©soudre les probl√®mes pratiques
      - Guide l'utilisateur dans ses d√©marches
      - Si n√©cessaire, transf√®re √† un expert ou administrateur`,
    allowedRoles: ['admin', 'support'],
    // Configuration suppl√©mentaire pour le support
    canAccessUserHistory: true,  // Peut voir l'historique des utilisateurs
    canEscalateToAdmin: true,    // Peut transf√©rer aux administrateurs
    canViewSensitiveData: false  // Ne peut pas voir les donn√©es sensibles
  },
  // R√¥le pour l'agent AI avec acc√®s complet
  ai_agent: {
    name: 'Agent IA',
    description: 'Assistant conversationnel intelligent pour utilisateurs et administrateurs',
    allowedRoles: ['*'], // Accessible par tous, y compris les non-authentifi√©s
    systemPrompt: `Vous √™tes un agent conversationnel IA avanc√© con√ßu pour aider les utilisateurs et les administrateurs.
      - Adaptez votre ton en fonction du r√¥le de l'utilisateur (user, admin, support)
      - Fournissez des r√©ponses pr√©cises et utiles
      - Pour les utilisateurs : fournissez des r√©ponses claires et simples
      - Pour les administrateurs : incluez des d√©tails techniques si n√©cessaire
      - Soyez courtois et professionnel en toutes circonstances
      - Guidez les utilisateurs vers les bonnes ressources`,
    // Configuration avanc√©e de l'agent AI
    canAccessUserHistory: true,    // Peut acc√©der √† l'historique
    canEscalateToHuman: true,      // Peut transf√©rer √† un humain si n√©cessaire
    canProvideDetailedInfo: true,  // Peut fournir des informations d√©taill√©es
    canInteractWith: ['user', 'admin', 'support'], // Peut interagir avec ces r√¥les
    isAlwaysAvailable: true        // Toujours disponible, m√™me sans authentification
  }
};

// V√©rification de la configuration des r√¥les
function validateRoleConfig() {
  console.log('=== V√âRIFICATION DE LA CONFIGURATION DES R√îLES ===');
  
  // V√©rifier que chaque r√¥le a les propri√©t√©s requises
  for (const [role, config] of Object.entries(ROLE_CONFIG)) {
    console.log(`\nV√©rification du r√¥le: ${role}`);
    
    // V√©rifier les propri√©t√©s requises
    const requiredProps = ['name', 'description', 'systemPrompt', 'allowedRoles'];
    for (const prop of requiredProps) {
      if (!(prop in config)) {
        console.error(`‚ùå Propri√©t√© manquante: ${prop} pour le r√¥le ${role}`);
      } else {
        console.log(`‚úì ${prop}: ${JSON.stringify(config[prop])}`);
      }
    }
    
    // V√©rifier que allowedRoles est un tableau
    if (config.allowedRoles && !Array.isArray(config.allowedRoles)) {
      console.error(`‚ùå allowedRoles doit √™tre un tableau pour le r√¥le ${role}`);
    }
  }
  
  console.log('=== FIN DE LA V√âRIFICATION ===\n');
}

// Valider la configuration au d√©marrage
validateRoleConfig();

export async function handleLegalChatbot(req, res) {
  console.log('=== D√©but de la requ√™te de chat ===');
  console.log('1. V√©rification des en-t√™tes de la requ√™te:', JSON.stringify(req.headers, null, 2));
  
  const { messages, role = 'assistant', systemPrompt } = req.body;
  const userId = req.user?.id;
  const isAdminRequest = role === 'admin';
  let conversation = null;
  
  // R√©cup√©rer ou initialiser les informations utilisateur
  const currentUserId = req.user?.id || 'anonymous';
  const currentUserRole = req.user?.role || 'guest';
  
  console.log('2. Donn√©es de la requ√™te re√ßues:', {
    hasMessages: Array.isArray(messages) ? `Oui (${messages.length} messages)` : 'Non',
    role,
    userId: currentUserId,
    userRole: currentUserRole,
    customSystemPrompt: !!systemPrompt
  });
  
  // V√©rifier si le r√¥le demand√© existe
  const roleConfig = ROLE_CONFIG[role];
  if (!roleConfig) {
    const availableRoles = Object.keys(ROLE_CONFIG);
    console.error(`R√¥le inconnu: ${role}`, { rolesDisponibles: availableRoles });
    
    return res.status(400).json({
      error: 'R√¥le invalide',
      reply: `D√©sol√©, le r√¥le "${role}" n'existe pas. R√¥les disponibles: ${availableRoles.join(', ')}`,
      details: {
        roleDemande: role,
        rolesDisponibles: availableRoles
      }
    });
  }
  
  // V√©rifier si l'utilisateur a la permission d'utiliser ce r√¥le
  console.log('V√©rification des permissions:', {
    role,
    currentUserRole,
    roleConfig: {
      name: roleConfig.name,
      allowedRoles: roleConfig.allowedRoles
    }
  });

  const isAdmin = currentUserRole === 'admin';
  let hasPermission = false;
  
  // V√©rifier les permissions sp√©ciales pour l'agent AI
  if (role === 'ai_agent') {
    // L'agent AI est toujours accessible √† tous
    hasPermission = true;
    console.log('Acc√®s accord√© pour l\'agent AI - acc√®s public activ√©');
  } else {
    // V√©rifier les permissions pour les autres r√¥les
    const isPublicRole = role === 'assistant';
    const allowedRoles = roleConfig.allowedRoles || [];
    
    console.log('V√©rification des permissions d√©taill√©e:', {
      isPublicRole,
      isAdmin,
      userRole: currentUserRole,
      allowedRoles,
      hasRoleAccess: allowedRoles.includes(currentUserRole),
      hasWildcardAccess: allowedRoles.includes('*')
    });
    
    hasPermission = isPublicRole || 
                   isAdmin || 
                   (allowedRoles.includes(currentUserRole) || 
                    allowedRoles.includes('*'));
  }
  
  console.log('R√©sultat de la v√©rification des permissions:', { hasPermission });
  
  if (!hasPermission) {
    const errorDetails = {
      timestamp: new Date().toISOString(),
      userId: currentUserId,
      userRole: currentUserRole,
      requestedRole: role,
      allowedRoles: roleConfig.allowedRoles,
      isAdmin
    };
    
    console.error('Acc√®s refus√© - D√©tails:', JSON.stringify(errorDetails, null, 2));
    
    return res.status(403).json({
      error: 'Acc√®s non autoris√©',
      reply: `D√©sol√©, vous n'avez pas les autorisations n√©cessaires pour acc√©der au mode "${roleConfig.name}".`,
      details: errorDetails
    });
  }
  
  try {
    console.log('3. V√©rification de l\'utilisateur...');
    if (!userId) {
      const error = 'Erreur: Utilisateur non authentifi√©';
      console.error(error);
      return res.status(401).json({ 
        error: 'Non autoris√©', 
        reply: 'Veuillez vous connecter pour utiliser le chatbot.',
        details: error
      });
    }
    console.log('5. Utilisateur v√©rifi√© avec succ√®s (ID:', userId, ')');
    
    console.log('3. V√©rification des messages...');
    console.log('Messages re√ßus:', JSON.stringify(messages, null, 2));
    
    if (!Array.isArray(messages) || messages.length === 0) {
      console.error('Erreur: Aucun message √† traiter');
      return res.status(400).json({ 
        error: 'Messages invalides', 
        reply: 'Aucun message √† traiter.' 
      });
    }
    console.log('4. Messages valides trouv√©s (nombre:', messages.length, ')');
    
    // V√©rifier le r√¥le de l'utilisateur
    console.log('5. V√©rification du r√¥le utilisateur...');
    const userRole = req.user?.role || 'user';
    const isAdmin = userRole === 'admin';
    console.log(`5.1. R√¥le utilisateur: ${userRole}, Admin: ${isAdmin}`);
    
    // Construire le prompt syst√®me avec le r√¥le appropri√©
    console.log('6. Construction du prompt syst√®me...');
    
    // V√©rifier si le r√¥le demand√© existe dans la configuration
    const roleConfig = ROLE_CONFIG[role] || ROLE_CONFIG.assistant;
    
    // Utiliser le prompt syst√®me du r√¥le ou celui fourni dans la requ√™te
    let systemPromptFinal = systemPrompt || roleConfig.systemPrompt;
    
    // Ajouter des informations contextuelles
    const currentDateTime = new Date().toLocaleString('fr-FR', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    systemPromptFinal += `\n\n[INFORMATIONS DU SYST√àME]\n`;
    systemPromptFinal += `- Date et heure: ${currentDateTime}\n`;
    systemPromptFinal += `- R√¥le actif: ${roleConfig.name}\n`;
    systemPromptFinal += `- Niveau d'acc√®s: ${userRole === 'admin' ? 'Administrateur' : (userRole === 'support' ? 'Support' : 'Utilisateur standard')}\n`;
    
    // Informations suppl√©mentaires bas√©es sur le r√¥le
    if (userRole === 'admin') {
      systemPromptFinal += `- PRIVIL√àGES ADMIN: Acc√®s complet √† toutes les fonctionnalit√©s\n`;
      systemPromptFinal += `- Vous pouvez g√©rer les utilisateurs et les param√®tres\n`;
    } else if (userRole === 'support') {
      systemPromptFinal += `- PRIVIL√àGES SUPPORT: Acc√®s √† l'historique des conversations\n`;
      systemPromptFinal += `- Vous pouvez transf√©rer les demandes complexes √† un administrateur\n`;
    }
    
    // Ajouter le contexte de la conversation
    systemPromptFinal += `\n[CONTEXTE DE LA CONVERSATION]\n`;
    systemPromptFinal += `- Vous parlez avec un utilisateur ayant le r√¥le: ${userRole}\n`;
    systemPromptFinal += `- Soyez professionnel et courtois en toutes circonstances\n`;
    
    // Instructions suppl√©mentaires pour l'agent AI
    if (role === 'ai_agent') {
      systemPromptFinal += `\n[INSTRUCTIONS SP√âCIFIQUES POUR L'AGENT IA]\n`;
      systemPromptFinal += `- Adaptez votre ton en fonction du r√¥le de l'utilisateur\n`;
      systemPromptFinal += `- Soyez concis mais complet dans vos r√©ponses\n`;
      systemPromptFinal += `- Si vous n'√™tes pas s√ªr d'une r√©ponse, dites-le clairement\n`;
      systemPromptFinal += `- Pour les questions complexes, proposez de transf√©rer √† un humain\n`;
    }
    
    // Ajouter des informations suppl√©mentaires pour les administrateurs
    if (isAdmin) {
      systemPromptFinal += '\n\n[INFORMATIONS ADMINISTRATEUR]\n';
      systemPromptFinal += '- Vous avez des privil√®ges administrateur\n';
      systemPromptFinal += '- Vous pouvez acc√©der √† des fonctionnalit√©s avanc√©es\n';
      systemPromptFinal += '- Date et heure actuelles: ' + new Date().toLocaleString('fr-FR') + '\n';
      systemPromptFinal += '- ID de la conversation: ' + conversation.id;
    }
    
    console.log('6.1. Prompt syst√®me final (longueur:', systemPromptFinal.length, 'caract√®res)');
    console.log('6.2. Extrait du prompt syst√®me:"', systemPromptFinal.substring(0, 100) + '..."');
    
    // R√©cup√©rer ou cr√©er une conversation
    console.log('7. R√©cup√©ration/cr√©ation de la conversation...');
    const conversation = await getOrCreateConversation(userId);
    console.log(`7.1. Conversation r√©cup√©r√©e/cr√©√©e:`, conversation);
    
    if (!conversation || !conversation.id) {
      throw new Error('√âchec de la cr√©ation/r√©cup√©ration de la conversation');
    }
    
    // R√©cup√©rer le dernier message utilisateur
    console.log('8. R√©cup√©ration du dernier message utilisateur...');
    const lastUserMessage = messages[messages.length - 1];
    console.log('8.1. Dernier message utilisateur:', {
      role: lastUserMessage.role,
      contentLength: lastUserMessage.content?.length,
      contentPreview: lastUserMessage.content?.substring(0, 50) + (lastUserMessage.content?.length > 50 ? '...' : '')
    });
    
    // Enregistrer le message utilisateur
    console.log('9. Enregistrement du message utilisateur...');
    await saveMessage(conversation.id, 'user', lastUserMessage.content, userId);
    console.log('9.1. Message utilisateur enregistr√© avec succ√®s');
    
    // Pr√©parer les messages pour l'API
    console.log('10. Pr√©paration des messages pour l\'API...');
    
    // Cr√©er le message syst√®me avec le prompt final
    const systemMessage = { role: 'system', content: systemPromptFinal };
    
    // Formater les messages utilisateur/assistant
    const formattedMessages = messages.map(msg => ({
      role: msg.role === 'assistant' ? 'assistant' : 'user',
      content: msg.content
    }));
    
    // Combiner les messages avec le message syst√®me en premier
    const fullMessages = [systemMessage, ...formattedMessages];
    
    console.log('10.1. Messages format√©s pour l\'API:');
    fullMessages.forEach((msg, i) => {
      console.log(`   Message ${i} (${msg.role}):`, {
        contentLength: msg.content?.length || 0,
        contentPreview: msg.content ? 
          (msg.content.length > 50 ? msg.content.substring(0, 50) + '...' : msg.content) : 
          'Aucun contenu'
      });
    });

    let response;
    
    console.log('11. Initialisation du mod√®le Gemini...');
    
    if (!process.env.GEMINI_API_KEY) {
      throw new Error('Cl√© API Gemini non configur√©e');
    }
    
    try {
      
      console.log('11.1. Configuration du mod√®le Gemini...');
      const model = genAI.getGenerativeModel({ 
        model: 'gemini-pro',
        generationConfig: {
          maxOutputTokens: 1000,
          temperature: role === 'expert' ? 0.3 : 0.7,
          topP: 0.95,
          topK: 40
        }
      });
      
      // Pr√©parer l'historique de conversation
      console.log('11.2. Pr√©paration de l\'historique de conversation...');
      const chat = model.startChat({
        history: [
          {
            role: 'user',
            parts: [{ text: systemPromptFinal }]
          },
          {
            role: 'model',
            parts: [{ text: 'Je suis pr√™t √† vous aider. Comment puis-je vous assister aujourd\'hui ?' }]
          }
        ]
      });
      
      console.log('11.3. Envoi du message utilisateur...');
      const userMessage = lastUserMessage.content;
      console.log('11.4. Taille du message utilisateur:', userMessage.length, 'caract√®res');
      
      const result = await chat.sendMessage(userMessage);
      console.log('11.5. R√©ponse brute re√ßue de Gemini');
      
      if (!result || !result.response) {
        throw new Error('R√©ponse invalide de l\'API Gemini');
      }
      
      response = await result.response.text();
      console.log('11.6. R√©ponse trait√©e, longueur:', response?.length || 0);
      
      if (!response) {
        throw new Error('R√©ponse vide de l\'API Gemini');
      }
    } catch (apiError) {
      console.error('11.7. Erreur lors de l\'appel √† l\'API Gemini:', {
        message: apiError.message,
        stack: apiError.stack,
        code: apiError.code,
        status: apiError.status
      });
      throw new Error(`Erreur lors de la g√©n√©ration de la r√©ponse: ${apiError.message}`);
    }

    console.log('R√©ponse IA re√ßue, enregistrement dans la base de donn√©es...');
    
    // Enregistrer la r√©ponse de l'assistant
    try {
      await saveMessage(conversation.id, 'assistant', response, userId);
      console.log('R√©ponse enregistr√©e avec succ√®s dans la base de donn√©es');
    } catch (saveError) {
      console.error('Erreur lors de l\'enregistrement de la r√©ponse:', {
        error: saveError.message,
        stack: saveError.stack,
        conversationId: conversation.id,
        responseLength: response?.length
      });
      throw saveError;
    }

    // Formater la r√©ponse en fonction du r√¥le
    let formattedResponse = response;
    
    if (isAdmin && isAdminRequest) {
      formattedResponse = `üîí [R√âPONSE ADMIN]\n${response}\n\n*Cette r√©ponse contient des informations sensibles accessibles uniquement aux administrateurs*`;
    } else if (isAdmin) {
      formattedResponse = `${response}\n\n[Note: Mode utilisateur actif - Utilisez le s√©lecteur de r√¥le pour acc√©der aux fonctionnalit√©s admin]`;
    }
    
    // Enregistrer la r√©ponse de l'IA
    console.log('13. Enregistrement de la r√©ponse de l\'IA...');
    await saveMessage(conversation.id, 'assistant', response, null);
    
    // Ajouter des m√©tadonn√©es utiles pour le d√©bogage
    const responseData = {
      reply: formattedResponse,
      isAdmin: isAdmin,
      usedAdminRights: isAdminRequest,
      metadata: {
        role: role,
        conversationId: conversation.id,
        timestamp: new Date().toISOString(),
        model: 'gemini-pro'
      }
    };
    
    console.log('14. Envoi de la r√©ponse au client:', JSON.stringify({
      replyLength: responseData.reply.length,
      ...responseData.metadata
    }, null, 2));
    
    return res.status(200).json(responseData);
    return;
  } catch (error) {
    const timestamp = new Date().toISOString();
    const errorId = `err_${Math.random().toString(36).substring(2, 10)}`;
    const isDevelopment = process.env.NODE_ENV === 'development';
    
    // D√©tails de l'erreur pour les logs
    const errorDetails = {
      errorId,
      timestamp,
      message: error.message,
      errorType: error.name,
      stack: error.stack,
      userId: req.user?.id || 'non_authentifi√©',
      userRole: req.user?.role || 'invit√©',
      requestedRole: req.body?.role,
      conversationId: conversation?.id || 'non_d√©fini',
      requestMethod: req.method,
      requestPath: req.path,
      requestBody: req.body ? JSON.stringify(req.body, null, 2) : 'aucun corps de requ√™te'
    };
    
    // Journalisation d√©taill√©e
    console.error(`[${timestamp}] [${errorId}] ERREUR CRITIQUE:`, JSON.stringify(errorDetails, null, 2));
    
    // D√©terminer le type d'erreur et le message appropri√©
    let statusCode = 500;
    let userMessage = 'Une erreur est survenue. Veuillez r√©essayer plus tard.';
    let technicalDetails = null;
    
    // Gestion sp√©cifique des types d'erreur
    if (error.name === 'AuthenticationError') {
      statusCode = 401;
      userMessage = 'Authentification requise. Veuillez vous connecter.';
    } else if (error.name === 'AuthorizationError') {
      statusCode = 403;
      userMessage = 'Acc√®s refus√©. Vous n\'avez pas les permissions n√©cessaires.';
    } else if (error.name === 'ValidationError') {
      statusCode = 400;
      userMessage = 'Donn√©es de requ√™te invalides.';
      technicalDetails = error.details;
    } else if (error.message?.includes('API key not valid')) {
      statusCode = 500;
      userMessage = 'Erreur de configuration du service. Veuillez contacter le support.';
      console.error('ERREUR CRITIQUE: Cl√© API invalide ou manquante');
    }
    
    // Pr√©parer la r√©ponse d'erreur
    const errorResponse = {
      error: {
        id: errorId,
        code: statusCode,
        message: userMessage,
        timestamp,
        ...(isDevelopment && {
          details: technicalDetails || error.details,
          type: error.name,
          stack: error.stack,
          request: {
            method: req.method,
            path: req.path,
            query: req.query,
            params: req.params
          }
        })
      }
    };
    
    // Envoyer la r√©ponse d'erreur
    console.error(`[${timestamp}] [${errorId}] R√©ponse d'erreur:`, JSON.stringify({
      status: statusCode,
      message: userMessage,
      errorId,
      ...(isDevelopment && { details: error.details })
    }, null, 2));
    
    return res.status(statusCode).json(errorResponse);
  }
}

/**
 * R√©cup√®re la liste des conversations de l'utilisateur
 */
export async function getConversations(req, res) {
  const userId = req.user?.id;

  try {
    const { data, error } = await supabase
      .from('conversations')
      .select('id, title, created_at, updated_at')
      .eq('user_id', userId)
      .eq('is_active', true)
      .order('updated_at', { ascending: false });

    if (error) throw error;

    res.json(data);
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des conversations:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la r√©cup√©ration des conversations',
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
}

/**
 * R√©cup√®re les messages d'une conversation sp√©cifique
 */
export async function getMessages(req, res) {
  const { id: conversationId } = req.params;
  const userId = req.user?.id;

  try {
    // V√©rifier que l'utilisateur a acc√®s √† cette conversation
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId)
      .single();

    if (convError || !conversation) {
      return res.status(404).json({ error: 'Conversation non trouv√©e ou acc√®s refus√©' });
    }

    const { data, error } = await supabase
      .from('messages')
      .select('id, role, content, created_at')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });

    if (error) throw error;

    res.json(data);
  } catch (error) {
    console.error('Erreur lors du traitement de la requ√™te:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      body: req.body,
      user: req.user,
      timestamp: new Date().toISOString()
    });
    
    const errorResponse = {
      error: 'Erreur lors du traitement de la requ√™te',
      message: error.message,
      ...(process.env.NODE_ENV === 'development' && { 
        stack: error.stack,
        code: error.code
      })
    };
    
    res.status(500).json(errorResponse);
  } finally {
    if (client) {
      client.release();
    }
  }
}

/**
 * Supprime une conversation (marquage comme inactif)
 */
export async function deleteConversation(req, res) {
  const { id: conversationId } = req.params;
  const userId = req.user?.id;
  const client = await pool.connect();

  try {
    // V√©rifier que l'utilisateur est propri√©taire de la conversation
    const { data: conversation, error: convError } = await supabase
      .from('conversations')
      .select('id')
      .eq('id', conversationId)
      .eq('user_id', userId);

    if (convError || !conversation || conversation.length === 0) {
      return res.status(404).json({ error: 'Conversation non trouv√©e ou acc√®s refus√©' });
    }

    // Marquer la conversation comme inactive
    await client.query(
      'UPDATE chat_conversations SET is_active = false WHERE id = $1',
      [conversationId]
    );

    res.json({ success: true, message: 'Conversation supprim√©e avec succ√®s' });
  } catch (error) {
    console.error('Erreur lors du traitement de la requ√™te:', {
      message: error.message,
      stack: error.stack,
      code: error.code,
      body: req.body,
      user: req.user,
      timestamp: new Date().toISOString()
    });
    
    const errorResponse = {
      error: 'Erreur lors du traitement de la requ√™te',
      message: error.message,
      ...(process.env.NODE_ENV === 'development' && { 
        stack: error.stack,
        code: error.code
      })
    };
    
    res.status(500).json(errorResponse);
  } finally {
    if (client) {
      client.release();
    }
  }
}